<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Blogs on George Karampelas</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Blogs on George Karampelas</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 21 Oct 2024 23:16:47 +0300</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Bad Quality Code</title>
      <link>http://localhost:1313/posts/bad-quality-code/</link>
      <pubDate>Mon, 21 Oct 2024 23:16:47 +0300</pubDate>
      <guid>http://localhost:1313/posts/bad-quality-code/</guid>
      <description>&lt;p&gt;How bad is low quality code on our days?&lt;/p&gt;&#xA;&lt;p&gt;As a programmer the last one and a half year, I am gonna say about something that everyone codes have said. Bad quality of code, yep that&amp;rsquo;s my topic. I am consider as the newest and lower seniority on my team, but after one and a half year of my career on the same project I miss my first days of just coding. Why? Because after some time of &amp;ldquo;PURE&amp;rdquo; implementation, testers found some bugs, something broken on production, change request from the client etc. Most of the times the problem is so small, bad quality of code that it is not readable maintainable and editable, for that reason you waste more time to understand the code than understand what the client asked again.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>How bad is low quality code on our days?</p>
<p>As a programmer the last one and a half year, I am gonna say about something that everyone codes have said. Bad quality of code, yep that&rsquo;s my topic. I am consider as the newest and lower seniority on my team, but after one and a half year of my career on the same project I miss my first days of just coding. Why? Because after some time of &ldquo;PURE&rdquo; implementation, testers found some bugs, something broken on production, change request from the client etc. Most of the times the problem is so small, bad quality of code that it is not readable maintainable and editable, for that reason you waste more time to understand the code than understand what the client asked again.</p>
<p>Let&rsquo;s talk with an example, you want to create a service that handle all the business logic of an entity and for one action this entity has numerous scenarios. As I believe it is a bad practice to use just a switch and split the code on numerous private methods to make the code look good, it is not. Do you know why?</p>
<ul>
<li>
<p>I can&rsquo;t read it</p>
</li>
<li>
<p>I can&rsquo;t maintain it</p>
</li>
<li>
<p>I can&rsquo;t test it</p>
</li>
<li>
<p>I can&rsquo;t extend it</p>
</li>
<li>
<p>I can&rsquo;t reuse it</p>
</li>
<li>
<p>I can&rsquo;t document it</p>
</li>
</ul>
<p>For all these reasons it would be better to split this business logic one more services if it is necessary or you can use Strategy Pattern. Feel free to explore the huge world of programming.</p>
<p>As I like, I code with TDD so I try to code the way I can test, obviously not using @Autowired. I write my basic scenarios with empty methods that I am gonna implement after my basic tests I start implement as I go my code is ugly and not perfect or acceptable for a merge request, but it works it passes the tests then I refactor my code to be more readable, maintainable and editable as the tests are green.</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
